<?php

namespace DreamFactory\Core\IbmDb2\Database\Schema;

use DreamFactory\Core\Database\Schema\ColumnSchema;
use DreamFactory\Core\Database\Schema\FunctionSchema;
use DreamFactory\Core\Database\Schema\ParameterSchema;
use DreamFactory\Core\Database\Schema\ProcedureSchema;
use DreamFactory\Core\Database\Schema\RoutineSchema;
use DreamFactory\Core\Database\Schema\TableSchema;
use DreamFactory\Core\Enums\DbSimpleTypes;
use DreamFactory\Core\Exceptions\InternalServerErrorException;
use DreamFactory\Core\SqlDb\Database\Schema\SqlSchema;

/**
 * Schema is the class for retrieving metadata information from a IBM DB2 database.
 */
class IbmSchema extends SqlSchema
{
    // Versions require different catalog views to access schema information
    const DB2_ISERIES = 0; // uses QSYS2
    const DB2_LUW = 1; // uses SYSCAT
    const DB2_ZOS = 2; // uses SYSIBM

    /**
     * @type integer
     */
    protected $series = null;

    protected function getDB2Series()
    {
        if ($this->series) {
            return $this->series;
        }

        try {
            $this->connection->select('SELECT TABNAME FROM SYSCAT.TABLES FETCH FIRST 1 ROWS ONLY');

            $this->series = static::DB2_LUW;
        } catch (\Exception $ex) {
            try {
                $this->connection->select('SELECT TABLE_NAME FROM QSYS2.SYSTABLES FETCH FIRST 1 ROWS ONLY');

                $this->series = static::DB2_ISERIES;
            } catch (\Exception $ex) {
                try {
                    $this->connection->select('SELECT NAME FROM SYSIBM.SYSTABLES FETCH FIRST 1 ROWS ONLY');

                    $this->series = static::DB2_ZOS;
                } catch (\Exception $ex) {
//        try {
//            $this->connection->select('SELECT TABLE_NAME FROM SYSIBM.SQLTABLES FETCH FIRST 1 ROWS ONLY');
//
//            $this->series = static::DB2_ODBC;
//        } catch (\Exception $ex) {
                    throw new InternalServerErrorException('Failed to determine valid system catalog for schema detection.');
//        }
//
                }
            }
        }

        return $this->series;
    }

    /**
     * @inheritdoc
     */
    public static function isUndiscoverableType($type)
    {
        switch ($type) {
            case DbSimpleTypes::TYPE_BOOLEAN:
                return true;
        }

        return parent::isUndiscoverableType($type);
    }

    /**
     * @inheritdoc
     */
    protected function translateSimpleColumnTypes(array &$info)
    {
        // override this in each schema class
        $type = (isset($info['type'])) ? $info['type'] : null;
        switch (strtolower($type)) {
            // some types need massaging, some need other required properties
            case 'pk':
            case DbSimpleTypes::TYPE_ID:
                $info['type'] = 'integer';
                $info['allow_null'] = false;
                $info['auto_increment'] = true;
                $info['is_primary_key'] = true;
                break;

            case 'fk':
            case DbSimpleTypes::TYPE_REF:
                $info['type'] = 'integer';
                $info['is_foreign_key'] = true;
                // check foreign tables
                break;

            case DbSimpleTypes::TYPE_TIMESTAMP_ON_CREATE:
                $info['type'] = 'timestamp';
                $info['allow_null'] = false;
                $default = (isset($info['default'])) ? $info['default'] : null;
                if (!isset($default)) {
                    $info['default'] = 'current timestamp';
                }
                break;
            case DbSimpleTypes::TYPE_TIMESTAMP_ON_UPDATE:
                $info['type'] = 'timestamp';
                $info['allow_null'] = false;
                $default = (isset($info['default'])) ? $info['default'] : null;
                if (!isset($default)) {
                    $info['default'] = 'generated by default for each row on update as row change timestamp';
                } else {
                    $info['default'] = $default;
                }
                break;

            case DbSimpleTypes::TYPE_USER_ID:
            case DbSimpleTypes::TYPE_USER_ID_ON_CREATE:
            case DbSimpleTypes::TYPE_USER_ID_ON_UPDATE:
                $info['type'] = 'integer';
                break;

            case DbSimpleTypes::TYPE_DATETIME:
                $info['type'] = 'TIMESTAMP';
                break;

            case DbSimpleTypes::TYPE_FLOAT:
                $info['type'] = 'REAL';
                break;

            case DbSimpleTypes::TYPE_DOUBLE:
                $info['type'] = 'DOUBLE';
                break;

            case DbSimpleTypes::TYPE_MONEY:
                $info['type'] = 'decimal';
                $info['type_extras'] = '(19,4)';
                break;

            case DbSimpleTypes::TYPE_BOOLEAN:
                $info['type'] = 'smallint';
                $default = (isset($info['default'])) ? $info['default'] : null;
                if (isset($default)) {
                    // convert to bit 0 or 1, where necessary
                    $info['default'] = (int)filter_var($default, FILTER_VALIDATE_BOOLEAN);
                }
                break;

            case DbSimpleTypes::TYPE_STRING:
                $fixed =
                    (isset($info['fixed_length'])) ? filter_var($info['fixed_length'], FILTER_VALIDATE_BOOLEAN) : false;
                $national =
                    (isset($info['supports_multibyte'])) ? filter_var($info['supports_multibyte'],
                        FILTER_VALIDATE_BOOLEAN) : false;
                if ($fixed) {
                    $info['type'] = ($national) ? 'graphic' : 'character';
                } elseif ($national) {
                    $info['type'] = 'vargraphic';
                } else {
                    $info['type'] = 'varchar';
                }
                break;

            case DbSimpleTypes::TYPE_TEXT:
                $info['type'] = 'CLOB';
                break;

            case DbSimpleTypes::TYPE_BINARY:
                $fixed =
                    (isset($info['fixed_length'])) ? filter_var($info['fixed_length'], FILTER_VALIDATE_BOOLEAN) : false;
                $info['type'] = ($fixed) ? 'binary' : 'varbinary';
                break;
        }
    }

    /**
     * @inheritdoc
     */
    protected function validateColumnSettings(array &$info)
    {
        // override this in each schema class
        $type = (isset($info['type'])) ? $info['type'] : null;
        switch (strtolower($type)) {
            // some types need massaging, some need other required properties
            case 'smallint':
            case 'int':
            case 'bigint':
                $default = (isset($info['default'])) ? $info['default'] : null;
                if (isset($default) && is_numeric($default)) {
                    $info['default'] = intval($default);
                }
                break;

            case 'decimal':
            case 'numeric':
            case 'real':
            case 'float':
            case 'double':
                if (!isset($info['type_extras'])) {
                    $length =
                        (isset($info['length']))
                            ? $info['length']
                            : ((isset($info['precision'])) ? $info['precision']
                            : null);
                    if (!empty($length)) {
                        $scale =
                            (isset($info['decimals']))
                                ? $info['decimals']
                                : ((isset($info['scale'])) ? $info['scale']
                                : null);
                        $info['type_extras'] = (!empty($scale)) ? "($length,$scale)" : "($length)";
                    }
                }

                $default = (isset($info['default'])) ? $info['default'] : null;
                if (isset($default) && is_numeric($default)) {
                    $info['default'] = floatval($default);
                }
                break;

            case 'character':
            case 'graphic':
            case 'binary':
            case 'varchar':
            case 'vargraphic':
            case 'varbinary':
            case 'clob':
            case 'dbclob':
            case 'blob':
                $length = (isset($info['length'])) ? $info['length'] : ((isset($info['size'])) ? $info['size'] : 255);
                if (isset($length)) {
                    $info['type_extras'] = "($length)";
                }
                break;

            case 'time':
            case 'timestamp':
            case 'datetime':
                $default = (isset($info['default'])) ? $info['default'] : null;
                if ('0000-00-00 00:00:00' == $default) {
                    // read back from MySQL has formatted zeros, can't send that back
                    $info['default'] = 0;
                }

                $length = (isset($info['length'])) ? $info['length'] : ((isset($info['size'])) ? $info['size'] : null);
                if (isset($length)) {
                    $info['type_extras'] = "($length)";
                }
                break;
        }
    }

    /**
     * @param array $info
     *
     * @return string
     * @throws \Exception
     */
    protected function buildColumnDefinition(array $info)
    {
        $type = (isset($info['type'])) ? $info['type'] : null;
        $typeExtras = (isset($info['type_extras'])) ? $info['type_extras'] : null;

        $definition = $type . $typeExtras;

        $allowNull = (isset($info['allow_null'])) ? filter_var($info['allow_null'], FILTER_VALIDATE_BOOLEAN) : false;
        $definition .= ($allowNull) ? ' NULL' : ' NOT NULL';

        $default = (isset($info['default'])) ? $info['default'] : null;
        if (isset($default)) {
            $quoteDefault =
                (isset($info['quote_default'])) ? filter_var($info['quote_default'], FILTER_VALIDATE_BOOLEAN) : false;
            if ($quoteDefault) {
                $default = "'" . $default . "'";
            }

            if ('generated by default for each row on update as row change timestamp' === $default) {
                $definition .= ' ' . $default;
            } else {
                $definition .= ' DEFAULT ' . $default;
            }
        }

        if (isset($info['is_primary_key']) && filter_var($info['is_primary_key'], FILTER_VALIDATE_BOOLEAN)) {
            $definition .= ' PRIMARY KEY';
        } elseif (isset($info['is_unique']) && filter_var($info['is_unique'], FILTER_VALIDATE_BOOLEAN)) {
            $definition .= ' UNIQUE';
        }

        $auto = (isset($info['auto_increment'])) ? filter_var($info['auto_increment'], FILTER_VALIDATE_BOOLEAN) : false;
        if ($auto) {
            $definition .= ' GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1)';
        }

        return $definition;
    }

    public function requiresCreateIndex($unique = false, $on_create_table = false)
    {
        return !($unique && $on_create_table);
    }

    /**
     * Resets the sequence value of a table's primary key.
     * The sequence will be reset such that the primary key of the next new row inserted
     * will have the specified value or 1.
     *
     * @param TableSchema $table    the table schema whose primary key sequence will be reset
     * @param mixed       $value    the value for the primary key of the next new row inserted. If this is not set,
     *                              the next new row's primary key will have a value 1.
     */
    public function resetSequence($table, $value = null)
    {
        if ($table->sequenceName !== null &&
            is_string($table->primaryKey) &&
            $table->getColumn($table->primaryKey)->autoIncrement
        ) {
            if ($value === null) {
                $value = $this->selectValue("SELECT MAX({$table->primaryKey}) FROM {$table->quotedName}") + 1;
            } else {
                $value = (int)$value;
            }

            $this->connection
                ->statement("ALTER TABLE {$table->quotedName} ALTER COLUMN {$table->primaryKey} RESTART WITH $value");
        }
    }

    /**
     * {@InheritDoc}
     */
    public function addForeignKey($name, $table, $columns, $refTable, $refColumns, $delete = null, $update = null)
    {
        switch (strtoupper($update)) {
            case 'CASCADE':
            case 'SET NULL':
                $update = null; // not supported on update, only NO ACTION and RESTRICT
                break;
        }

        return parent::addForeignKey($name, $table, $columns, $refTable, $refColumns, $delete, $update);
    }

    /**
     * Builds a SQL statement for truncating a DB table.
     *
     * @param string $table the table to be truncated. The name will be properly quoted by the method.
     *
     * @return string the SQL statement for truncating a DB table.
     */
    public function truncateTable($table)
    {
        return "TRUNCATE TABLE " . $this->quoteTableName($table) . " IMMEDIATE ";
    }

    /**
     * Builds a SQL statement for changing the definition of a column.
     *
     * @param string $table      the table whose column is to be changed. The table name will be properly quoted by the
     *                           method.
     * @param string $column     the name of the column to be changed. The name will be properly quoted by the method.
     * @param string $definition the new column type. The {@link getColumnType} method will be invoked to convert
     *                           abstract column type (if any) into the physical one. Anything that is not recognized
     *                           as abstract type will be kept in the generated SQL. For example, 'string' will be
     *                           turned into 'varchar(255)', while 'string not null' will become 'varchar(255) not
     *                           null'.
     *
     * @return string the SQL statement for changing the definition of a column.
     */
    public function alterColumn($table, $column, $definition)
    {
        $allowNullNewType = !preg_match("/not +null/i", $definition);

        $definition = preg_replace("/ +(not)? *null/i", "", $definition);

        $sql = <<<MYSQL
ALTER TABLE $table ALTER COLUMN {$this->quoteColumnName($column)} SET DATA TYPE {$this->getColumnType($definition)}
MYSQL;

        if ($allowNullNewType) {
            $sql .= ' ALTER COLUMN ' . $this->quoteColumnName($column) . 'DROP NOT NULL';
        } else {
            $sql .= ' ALTER COLUMN ' . $this->quoteColumnName($column) . 'SET NOT NULL';
        }

        return $sql;
    }

    /**
     * @return string default schema.
     */
    public function getDefaultSchema()
    {
        $sql = <<<MYSQL
SELECT CURRENT SCHEMA FROM SYSIBM.SYSDUMMY1
MYSQL;

        return $this->selectValue($sql);
    }

    public function getSchemas()
    {
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
//            $sql = <<<MYSQL
//SELECT DISTINCT TABLE_SCHEMA FROM QSYS2.SYSTABLES WHERE SYSTEM_TABLE = 'N' ORDER BY TABLE_SCHEMA;
//MYSQL;
                $sql = <<<MYSQL
SELECT SCHEMA_NAME FROM QSYS2.SYSSCHEMAS ORDER BY SCHEMA_NAME;
MYSQL;
                break;
            case static::DB2_LUW:
                $sql = <<<MYSQL
SELECT SCHEMANAME FROM SYSCAT.SCHEMATA WHERE DEFINERTYPE != 'S' ORDER BY SCHEMANAME;
MYSQL;
                break;
            case static::DB2_ZOS:
                $sql = <<<MYSQL
SELECT DISTINCT CREATOR FROM SYSIBM.SYSTABLES WHERE CREATOR NOT LIKE 'SYS%' ORDER BY CREATOR;
MYSQL;
                // todo need to query SYSROUTINES as well
                break;
//            case static::DB2_ODBC:
//                $sql = <<<MYSQL
//select TABLE_SCHEM from SYSIBM.SQLSCHEMAS WHERE TABLE_SCHEM NOT LIKE 'SYS%';
//MYSQL;
//                break;
        }

        $rows = array_map('trim', $this->selectColumn($sql));

        return $rows;
    }

    protected function getTableNames($schema = '')
    {
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
                $sql = <<<MYSQL
SELECT TABLE_SCHEMA as TABSCHEMA, TABLE_NAME as TABNAME FROM QSYS2.SYSTABLES WHERE TABLE_TYPE = 'T' AND SYSTEM_TABLE = 'N'
MYSQL;
                if ($schema !== '') {
                    $sql .= <<<MYSQL
  AND TABLE_SCHEMA = :schema
MYSQL;
                }
                break;
            case static::DB2_LUW:
                $sql = <<<MYSQL
SELECT TABSCHEMA, TABNAME FROM SYSCAT.TABLES WHERE TYPE = 'T' AND OWNERTYPE != 'S'
MYSQL;
                if (!empty($schema)) {
                    $sql .= <<<MYSQL
  AND TABSCHEMA=:schema
MYSQL;
                }
                break;
            case static::DB2_ZOS:
                $sql = <<<MYSQL
SELECT CREATOR AS TABSCHEMA, NAME AS TABNAME FROM SYSIBM.SYSTABLES WHERE TYPE = 'T'
MYSQL;
                if (!empty($schema)) {
                    $sql .= <<<MYSQL
  AND CREATOR=:schema
MYSQL;
                }
                break;
//            case static::DB2_ODBC:
//                $sql = <<<MYSQL
//SELECT TABLE_SCHEM AS TABSCHEMA, TABLE_NAME AS TABNAME FROM SYSIBM.SQLTABLES WHERE TABLE_TYPE = 'TABLE'
//MYSQL;
//                if (!empty($schema)) {
//                    $sql .= <<<MYSQL
//  AND TABLE_SCHEM=:schema
//MYSQL;
//                }
//                break;
        }
        $sql .= <<<MYSQL
  ORDER BY TABNAME;
MYSQL;

        $params = (!empty($schema)) ? [':schema' => $schema] : [];
        $rows = $this->connection->select($sql, $params);

        $names = [];
        foreach ($rows as $row) {
            $row = array_change_key_case((array)$row, CASE_UPPER);
            $schemaName = trim(isset($row['TABSCHEMA']) ? $row['TABSCHEMA'] : '');
            $resourceName = trim(isset($row['TABNAME']) ? $row['TABNAME'] : '');
            $internalName = $schemaName . '.' . $resourceName;
            $name = $resourceName;
            $quotedName = $this->quoteTableName($schemaName) . '.' . $this->quoteTableName($resourceName);;
            $settings = compact('schemaName', 'resourceName', 'name', 'internalName', 'quotedName');
            $names[strtolower($name)] = new TableSchema($settings);
        }

        return $names;
    }

    protected function getViewNames($schema = '')
    {
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
                $sql = <<<MYSQL
SELECT TABLE_SCHEMA as TABSCHEMA, TABLE_NAME as TABNAME FROM QSYS2.SYSTABLES WHERE TABLE_TYPE = 'V' AND SYSTEM_TABLE = 'N'
MYSQL;
                if ($schema !== '') {
                    $sql .= <<<MYSQL
  AND TABLE_SCHEMA = :schema
MYSQL;
                }
                break;
            case static::DB2_LUW:
                $sql = <<<MYSQL
SELECT TABSCHEMA, TABNAME FROM SYSCAT.TABLES WHERE TYPE = 'V' AND OWNERTYPE != 'S'
MYSQL;
                if (!empty($schema)) {
                    $sql .= <<<MYSQL
  AND TABSCHEMA=:schema
MYSQL;
                }
                break;
            case static::DB2_ZOS:
                $sql = <<<MYSQL
SELECT CREATOR AS TABSCHEMA, NAME AS TABNAME FROM SYSIBM.SYSTABLES WHERE TYPE = 'V'
MYSQL;
                if (!empty($schema)) {
                    $sql .= <<<MYSQL
  AND CREATOR=:schema
MYSQL;
                }
                break;
//            case static::DB2_ODBC:
//                $sql = <<<MYSQL
//SELECT TABLE_SCHEM AS TABSCHEMA, TABLE_NAME AS TABNAME
//FROM SYSIBM.SQLTABLES
//WHERE TABLE_TYPE = 'VIEW'
//MYSQL;
//                if (!empty($schema)) {
//                    $sql .= <<<MYSQL
//  AND TABLE_SCHEM=:schema
//MYSQL;
//                }
//                break;
        }
        $sql .= <<<MYSQL
  ORDER BY TABNAME;
MYSQL;

        $params = (!empty($schema)) ? [':schema' => $schema] : [];
        $rows = $this->connection->select($sql, $params);

        $names = [];
        foreach ($rows as $row) {
            $row = array_change_key_case((array)$row, CASE_UPPER);
            $schemaName = trim(isset($row['TABSCHEMA']) ? $row['TABSCHEMA'] : '');
            $resourceName = trim(isset($row['TABNAME']) ? $row['TABNAME'] : '');
            $internalName = $schemaName . '.' . $resourceName;
            $name = $resourceName;
            $quotedName = $this->quoteTableName($schemaName) . '.' . $this->quoteTableName($resourceName);;
            $settings = compact('schemaName', 'resourceName', 'name', 'internalName', 'quotedName');
            $settings['isView'] = true;
            $names[strtolower($name)] = new TableSchema($settings);
        }

        return $names;
    }

    protected function loadTableColumns(TableSchema $table)
    {
        $params = [':table' => $table->resourceName, ':schema' => $table->schemaName];

        $series = $this->getDB2Series();
        switch ($series) {
            case static::DB2_ISERIES:
                $sql = <<<MYSQL
SELECT column_name AS colname,
       ordinal_position AS colno,
       data_type AS typename,
       CAST(column_default AS VARCHAR(254)) AS default,
       is_nullable AS nulls,
       length AS length,
       numeric_scale AS scale,
       is_identity AS identity
FROM qsys2.syscolumns
WHERE table_name = :table AND table_schema = :schema
ORDER BY ordinal_position
MYSQL;
                break;
            case static::DB2_LUW:
                $sql = <<<MYSQL
SELECT colname,
       colno,
       typename,
       CAST(default AS VARCHAR(254)) AS default,
       nulls,
       length,
       scale,
       identity
FROM syscat.columns
WHERE tabname = :table AND tabschema = :schema
ORDER BY colno
MYSQL;
                break;
            case static::DB2_ZOS:
                $sql = <<<MYSQL
SELECT name as colname,
       colno,
       coltype as typename,
       default,
       defaultValue,
       nulls,
       length,
       scale,
       keyseq
FROM SYSIBM.SYSCOLUMNS
WHERE tbname = :table AND tbcreator = :schema
ORDER BY colno
MYSQL;
                break;
//                case static::DB2_ODBC:
//                $sql = <<<MYSQL
//SELECT COLUMN_NAME as colname,
//       ORDINAL_POSITION as colno,
//       TYPE_NAME as typename,
//       CAST(column_def AS VARCHAR(254)) AS default,
//       nullable as nulls,
//       column_size as length,
//       decimal_digits as scale,
//       CASE pseudo_column
//         WHEN '1' THEN 'N'
//         WHEN '2' THEN 'Y'
//         ELSE NULL
//       END AS identity
//FROM SYSIBM.SQLCOLUMNS
//WHERE TABLE_SCHEM = :schema AND TABLE_NAME = :table
//ORDER BY ordinal_position
//MYSQL;
//                break;
        }

        $columns = $this->connection->select($sql, $params);
            foreach ($columns as $column) {
                $column = array_change_key_case((array)$column, CASE_LOWER);
                $c = new ColumnSchema(['name' => $column['colname']]);
                $c->quotedName = $this->quoteColumnName($c->name);
                switch ($series) {
                    case static::DB2_ZOS:
                        // handle default, defaultValue, and keyseq
                        $default = array_get($column, 'default');
                        unset($column['default']);
                        switch ($default) {
                            case 'A':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'I':
                            case 'J':
                                $column['identity'] = true;
                                break;
                            default:
                                $default = (int)$default;
                                if ($default > 1 && $default < 10) {
                                    $column['default'] = $column['defaultvalue'];
                                } else {
                                    $column['default'] = null;
                                }
                                break;
                        }
                        if (0 < (int)array_get($column, 'keyseq')) {
                            $column['is_primary_key'] = true;
                        }
                        break;
                }

                $c->allowNull = array_get_bool($column, 'nulls');
                $c->autoIncrement = array_get_bool($column, 'identity');
                $c->isPrimaryKey = array_get_bool($column, 'is_primary_key');
                $c->dbType = $column['typename'];

                if (preg_match('/(varchar|character|clob|graphic|binary|blob)/i', $c->dbType)) {
                    $c->size = $c->precision = $column['length'];
                } elseif (preg_match('/(decimal|double|real)/i', $c->dbType)) {
                    $c->size = $c->precision = $column['length'];
                    $c->scale = $column['scale'];
                }

                $c->fixedLength = $this->extractFixedLength($c->dbType);
                $c->supportsMultibyte = $this->extractMultiByteSupport($c->dbType);
                $this->extractType($c, $c->dbType);
                if (is_string($column['default'])) {
                    $column['default'] = trim($column['default'], '\'');
                }
                $default = ($column['default'] == "NULL") ? null : $column['default'];

                $this->extractDefault($c, $default);

                if ($c->isPrimaryKey) {
                    if ($c->autoIncrement) {
                        $table->sequenceName = array_get($column, 'sequence', $c->name);
                        if ((DbSimpleTypes::TYPE_INTEGER === $c->type)) {
                            $c->type = DbSimpleTypes::TYPE_ID;
                        }
                    }
                    $table->addPrimaryKey($c->name);
                }
                $table->addColumn($c);
            }
    }

    protected function getTableConstraints($schema = '')
    {
        if (is_array($schema)) {
            $schema = implode("','", $schema);
        }

        $constraints = [];
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
                $sql = <<<MYSQL
SELECT tc.constraint_name, tc.constraint_type, 
kcu.table_schema AS table_schema, kcu.table_name AS table_name, kcu.column_name AS column_name,
kcu2.table_schema AS referenced_table_schema, kcu2.table_name AS referenced_table_name, kcu2.column_name AS referenced_column_name,
rc.update_rule, rc.delete_rule
FROM qsys2.syscst tc
INNER JOIN qsys2.syskeycst kcu ON kcu.constraint_name = tc.constraint_name
INNER JOIN qsys2.sysrefcst rc ON tc.constraint_schema = rc.constraint_schema AND tc.constraint_name = rc.constraint_name
INNER JOIN qsys2.syskeycst kcu2 ON rc.unique_constraint_schema = kcu2.constraint_schema AND rc.unique_constraint_name = kcu2.constraint_name
WHERE tc.table_schema IN ('{$schema}');
MYSQL;
                break;
            case static::DB2_LUW:
                $sql = <<<SQL
SELECT tc.constname as constraint_name, tc.type as constraint_type, 
kcu.tabschema as table_schema, kcu.tabname as table_name, kcu.colname as column_name,
kcu2.tabschema as referenced_table_schema, kcu2.tabname as referenced_table_name, kcu2.colname as referenced_column_name, 
rc.updaterule as update_rule, rc.deleterule as delete_rule
FROM SYSCAT.TABCONST tc
LEFT JOIN SYSCAT.KEYCOLUSE kcu ON tc.constname = kcu.constname AND tc.tabname = kcu.tabname
LEFT JOIN SYSCAT.REFERENCES rc ON tc.constname = rc.constname
LEFT JOIN SYSCAT.KEYCOLUSE kcu2 ON rc.reftabschema = kcu2.tabschema AND rc.reftabname = kcu2.tabname AND rc.refkeyname = kcu2.constname AND kcu.colseq = kcu2.colseq
WHERE tc.tabschema IN ('{$schema}');
SQL;
                break;
            case static::DB2_ZOS:
                // prior to 12.0, PK and Unique constraints separate from FK
                $sql = <<<MYSQL
SELECT tc.CONSTNAME AS constraint_name, tc.TYPE as constraint_type, 
tc.TBCREATOR AS table_schema, tc.TBNAME as table_name, kcu.COLNAME AS column_name
FROM SYSIBM.SYSTABCONST tc
LEFT JOIN SYSIBM.SYSKEYCOLUSE kcu ON tc.constname = kcu.constname AND tc.tbname = kcu.tbname
WHERE tc.TBCREATOR IN ('{$schema}');
MYSQL;
                $results = $this->connection->select($sql);
                foreach ($results as $row) {
                    $row = array_change_key_case((array)$row, CASE_LOWER);
                    $ts = strtolower($row['table_schema']);
                    $tn = strtolower($row['table_name']);
                    $cn = strtolower($row['constraint_name']);
                    $colName = array_get($row, 'column_name');
                    if (isset($constraints[$ts][$tn][$cn])) {
                        $constraints[$ts][$tn][$cn]['column_name'] =
                            array_merge((array)$constraints[$ts][$tn][$cn]['column_name'], (array)$colName);
                    } else {
                        $constraints[$ts][$tn][$cn] = $row;
                    }
                }

                $sql = <<<MYSQL
SELECT rel.RELNAME AS constraint_name, 'F' as constraint_type, 
rel.CREATOR AS table_schema, rel.TBNAME as table_name, fk.COLNAME AS column_name,
rel.REFTBCREATOR AS referenced_table_schema, rel.REFTBNAME as referenced_table_name, fk.COLNAME AS referenced_column_name,
rel.DELETERULE as delete_rule
FROM SYSIBM.SYSRELS rel
INNER JOIN SYSIBM.SYSFOREIGNKEYS fk ON fk.RELNAME = rel.RELNAME
WHERE tc.TBCREATOR IN ('{$schema}');
MYSQL;
                break;
//            case static::DB2_ODBC:
//                    $sql = <<<MYSQL
//SELECT column_name
//FROM SYSIBM.SQLPRIMARYKEYS
//WHERE TABLE_NAME = :table AND TABLE_SCHEM = :schema
//MYSQL;
//
//                    $indexes = $this->connection->select($sql, $params);
//                    foreach ($indexes as $index) {
//                        $index = array_change_key_case((array)$index, CASE_LOWER);
//                        $name = $index['column_name'];
//                        foreach ($columns as &$column) {
//                            $column = array_change_key_case((array)$column, CASE_LOWER);
//                            if ($name === array_get($column, 'colname')) {
//                                $column['is_primary_key'] = true;
//                            }
//                        }
//                    }
//                $sql = <<<MYSQL
//SELECT
//  FKTABLE_SCHEM AS table_schema, FKTABLE_NAME as table_name, FKCOLUMN_NAME AS column_name,
//  PKTABLE_SCHEM AS referenced_table_schema, PKTABLE_NAME as referenced_table_name, PKCOLUMN_NAME AS referenced_column_name
//FROM SYSIBM.SQLFOREIGNKEYS
//MYSQL;
//                break;
        }

        $results = $this->connection->select($sql);
        foreach ($results as $row) {
            $row = array_change_key_case((array)$row, CASE_LOWER);
            $ts = strtolower($row['table_schema']);
            $tn = strtolower($row['table_name']);
            $cn = strtolower($row['constraint_name']);
            $colName = array_get($row, 'column_name');
            $refColName = array_get($row, 'referenced_column_name');
            if (isset($constraints[$ts][$tn][$cn])) {
                $constraints[$ts][$tn][$cn]['column_name'] =
                    array_merge((array)$constraints[$ts][$tn][$cn]['column_name'], (array)$colName);

                if (isset($refColName)) {
                    $constraints[$ts][$tn][$cn]['referenced_column_name'] =
                        array_merge((array)$constraints[$ts][$tn][$cn]['referenced_column_name'], (array)$refColName);
                }
            } else {
                $constraints[$ts][$tn][$cn] = $row;
            }
        }

        return $constraints;
    }

    protected function getRoutineNames($type, $schema = '')
    {
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
                $bindings = [':type' => $type];
                $where = "FUNCTION_ORIGIN != 'S' AND ROUTINE_TYPE = :type";
                if (!empty($schema)) {
                    $where .= ' AND ROUTINE_SCHEMA = :schema';
                    $bindings[':schema'] = $schema;
                }

                $sql = <<<MYSQL
SELECT ROUTINE_NAME AS ROUTINENAME, FUNCTION_TYPE AS FUNCTIONTYPE FROM QSYS2.SYSROUTINES WHERE {$where}
MYSQL;
                break;
            case static::DB2_LUW:
                $bindings = [':type' => $type[0]];
                $where = "OWNERTYPE != 'S' AND ROUTINETYPE = :type";
                if (!empty($schema)) {
                    $where .= ' AND ROUTINESCHEMA = :schema';
                    $bindings[':schema'] = $schema;
                }

                $sql = <<<MYSQL
SELECT ROUTINENAME, RETURN_TYPENAME, FUNCTIONTYPE FROM SYSCAT.ROUTINES WHERE {$where}
MYSQL;
                break;
            case static::DB2_ZOS:
                $bindings = [':type' => $type[0]];
                $where = "OWNERTYPE != 'S' AND ROUTINETYPE = :type";
                if (!empty($schema)) {
                    $where .= ' AND SCHEMA = :schema';
                    $bindings[':schema'] = $schema;
                }

                $sql = <<<MYSQL
SELECT NAME AS ROUTINENAME, RETURN_TYPE AS RETURN_TYPENAME, FUNCTION_TYPE AS FUNCTIONTYPE FROM SYSIBM.SYSROUTINES WHERE {$where}
MYSQL;
                break;
        }
        $rows = $this->connection->select($sql, $bindings);

        $names = [];
        foreach ($rows as $row) {
            $row = array_change_key_case((array)$row, CASE_UPPER);
            $resourceName = array_get($row, 'ROUTINENAME');
            $schemaName = $schema;
            $internalName = $schemaName . '.' . $resourceName;
            $name = $resourceName;
            $quotedName = $this->quoteTableName($schemaName) . '.' . $this->quoteTableName($resourceName);
            switch ($functionType = array_get($row, 'FUNCTIONTYPE')) {
                case 'R': // row
                    $returnType = DbSimpleTypes::TYPE_ROW;
                    break;
                case 'T': // table
                    $returnType = DbSimpleTypes::TYPE_TABLE;
                    break;
                case 'C': // column or aggregate
                    $returnType = DbSimpleTypes::TYPE_COLUMN;
                    break;
                case 'S': // scalar, return type should be set
                    if (!empty($returnType = array_get($row, 'RETURN_TYPENAME'))) {
                        $returnType = static::extractSimpleType($returnType);
                    }
                    break;
                default: // procedure
                    if (!empty($returnType = array_get($row, 'RETURN_TYPENAME'))) {
                        $returnType = static::extractSimpleType($returnType);
                    }
                    break;
            }
            $settings = compact('schemaName', 'resourceName', 'name', 'internalName', 'quotedName', 'returnType');
            $names[strtolower($name)] =
                ('PROCEDURE' === $type) ? new ProcedureSchema($settings) : new FunctionSchema($settings);
        }

        return $names;
    }

    protected function loadParameters(RoutineSchema $holder)
    {
        switch ($this->getDB2Series()) {
            case static::DB2_ISERIES:
                $sql = <<<MYSQL
SELECT ORDINAL_POSITION, PARAMETER_MODE, ROW_TYPE, PARAMETER_NAME, DATA_TYPE, NUMERIC_PRECISION, NUMERIC_SCALE, CHARACTER_MAXIMUM_LENGTH, DEFAULT
FROM QSYS2.SYSPARMS
WHERE SPECIFIC_NAME = '{$holder->resourceName}' AND SPECIFIC_SCHEMA = '{$holder->schemaName}'
MYSQL;

                $rows = $this->connection->select($sql);
                foreach ($rows as $row) {
                    $row = array_change_key_case((array)$row, CASE_UPPER);
                    $paramName = array_get($row, 'PARAMETER_NAME');
                    $dbType = array_get($row, 'DATA_TYPE');
                    $simpleType = static::extractSimpleType($dbType);
                    $pos = intval(array_get($row, 'ORDINAL_POSITION'));
                    $length = (isset($row['CHARACTER_MAXIMUM_LENGTH']) ? intval(array_get($row,
                        'CHARACTER_MAXIMUM_LENGTH')) : null);
                    $precision = (isset($row['NUMERIC_PRECISION']) ? intval(array_get($row,
                        'NUMERIC_PRECISION')) : null);
                    $scale = (isset($row['NUMERIC_SCALE']) ? intval(array_get($row, 'NUMERIC_SCALE')) : null);
                    switch (strtoupper(array_get($row, 'ROW_TYPE', ''))) {
                        case 'P':
                            $paramType = array_get($row, 'PARAMETER_MODE');
                            $holder->addParameter(new ParameterSchema(
                                [
                                    'name'          => $paramName,
                                    'position'      => $pos,
                                    'param_type'    => $paramType,
                                    'type'          => $simpleType,
                                    'db_type'       => $dbType,
//                                'length'        => $length, possible PDO bug here
                                    'length'        => ($dbType == "CHARACTER") ? $length + 1 : $length,
                                    'precision'     => $precision,
                                    'scale'         => $scale,
                                    'default_value' => array_get($row, 'DEFAULT'),
                                ]
                            ));
                            break;
                        case 'R':
                        case 'C':
                            $holder->returnSchema[] = [
                                'name'      => $paramName,
                                'position'  => $pos,
                                'type'      => $simpleType,
                                'db_type'   => $dbType,
                                'length'    => $length,
                                'precision' => $precision,
                                'scale'     => $scale,
                            ];
                            break;
                        default:
                            break;
                    }
                }
                break;
            case static::DB2_LUW:
                $sql = <<<MYSQL
SELECT ORDINAL, ROWTYPE, PARMNAME, TYPENAME, LENGTH, SCALE, DEFAULT
FROM SYSCAT.ROUTINEPARMS
WHERE ROUTINENAME = '{$holder->resourceName}' AND ROUTINESCHEMA = '{$holder->schemaName}'
MYSQL;
                break;
            case static::DB2_ZOS:
                $sql = <<<MYSQL
SELECT ORDINAL, ROWTYPE, PARMNAME, TYPENAME, LENGTH, SCALE, DEFAULT
FROM SYSIBM.SYSPARMS
WHERE NAME = '{$holder->resourceName}' AND SCHEMA = '{$holder->schemaName}'
MYSQL;
                break;
        }

        $rows = $this->connection->select($sql);
        foreach ($rows as $row) {
            $row = array_change_key_case((array)$row, CASE_UPPER);
            $paramName = array_get($row, 'PARMNAME');
            $dbType = array_get($row, 'TYPENAME');
            $simpleType = static::extractSimpleType($dbType);
            $pos = intval(array_get($row, 'ORDINAL'));
            $length = (isset($row['LENGTH']) ? intval(array_get($row, 'LENGTH')) : null);
            $scale = (isset($row['SCALE']) ? intval(array_get($row, 'SCALE')) : null);
            switch (strtoupper(array_get($row, 'ROWTYPE', ''))) {
                case 'P':
                    $paramType = 'IN';
                    break;
                case 'B':
                    $paramType = 'INOUT';
                    break;
                case 'O':
                    $paramType = 'OUT';
                    break;
                case 'R':
                case 'C':
                    $holder->returnSchema[] = [
                        'name'      => $paramName,
                        'position'  => $pos,
                        'type'      => $simpleType,
                        'db_type'   => $dbType,
                        'length'    => $length,
                        'precision' => $length,
                        'scale'     => $scale,
                    ];
                    continue 2;
                    break;
                default:
                    continue 2;
                    break;
            }
            if (0 === $pos) {
                if (empty($holder->returnType)) {
                    $holder->returnType = $simpleType;
                }
            } else {
                $holder->addParameter(new ParameterSchema(
                    [
                        'name'          => $paramName,
                        'position'      => $pos,
                        'param_type'    => $paramType,
                        'type'          => $simpleType,
                        'db_type'       => $dbType,
                        'length'        => $length,
                        'precision'     => $length,
                        'scale'         => $scale,
                        'default_value' => array_get($row, 'DEFAULT'),
                    ]
                ));
            }
        }
    }

    public static function getNativeDateTimeFormat($field_info)
    {
        $type = DbSimpleTypes::TYPE_STRING;
        if (is_string($field_info)) {
            $type = $field_info;
        } elseif ($field_info instanceof ColumnSchema) {
            $type = $field_info->type;
        } elseif ($field_info instanceof ParameterSchema) {
            $type = $field_info->type;
        }
        switch (strtolower(strval($type))) {
            case DbSimpleTypes::TYPE_DATE:
                return 'Y-m-d';

            case DbSimpleTypes::TYPE_TIME:
            case DbSimpleTypes::TYPE_TIME_TZ:
                return 'H:i:s';

            case DbSimpleTypes::TYPE_DATETIME:
            case DbSimpleTypes::TYPE_DATETIME_TZ:
            case DbSimpleTypes::TYPE_TIMESTAMP:
            case DbSimpleTypes::TYPE_TIMESTAMP_ON_CREATE:
            case DbSimpleTypes::TYPE_TIMESTAMP_ON_UPDATE:
            case DbSimpleTypes::TYPE_TIMESTAMP_TZ:
                return 'Y-m-d H:i:s.u';
        }

        return null;
    }

    public function getTimestampForSet()
    {
        return $this->connection->raw('(CURRENT TIMESTAMP)');
    }

    public function typecastToNative($value, $field_info, $allow_null = true)
    {
        $value = parent::typecastToNative($value, $field_info, $allow_null);

        switch ($field_info->type) {
            case DbSimpleTypes::TYPE_DECIMAL:
                return number_format($value, $field_info->scale, '.', '');
        }

        return $value;
    }

    /**
     * @inheritdoc
     */
    protected function getFunctionStatement(RoutineSchema $routine, array $param_schemas, array &$values)
    {
        switch ($routine->returnType) {
            case DbSimpleTypes::TYPE_ROW:
            case DbSimpleTypes::TYPE_TABLE:
                $paramStr = $this->getRoutineParamString($param_schemas, $values);

                return "SELECT * from TABLE({$routine->quotedName}($paramStr))";
                break;
            default:
                return parent::getFunctionStatement($routine, $param_schemas, $values) . ' FROM SYSIBM.SYSDUMMY1';
                break;
        }
    }

    protected function doRoutineBinding($statement, array $paramSchemas, array &$values)
    {
        foreach ($paramSchemas as $key => $paramSchema) {
            $pdoType = $this->extractPdoType($paramSchema->type);
            switch ($paramSchema->paramType) {
                case 'IN':
                    $this->bindValue($statement, ':' . $paramSchema->name, array_get($values, $key));
                    break;
                case 'INOUT':
                    if (empty($values[$key]) && (\PDO::PARAM_STR === $pdoType)) {
                        $values[$key] = str_repeat(" ", $paramSchema->length);
                    }
                    $this->bindParam(
                        $statement, ':' . $paramSchema->name,
                        $values[$key],
                        $pdoType | \PDO::PARAM_INPUT_OUTPUT,
                        $paramSchema->length
                    );
                    break;
                case 'OUT':
                    if (empty($values[$key]) && (\PDO::PARAM_STR === $pdoType)) {
                        $values[$key] = str_repeat(" ", $paramSchema->length);
                    }
                    $this->bindParam(
                        $statement, ':' . $paramSchema->name,
                        $values[$key],
                        $pdoType,
                        $paramSchema->length
                    );
                    break;
            }
        }
    }
}